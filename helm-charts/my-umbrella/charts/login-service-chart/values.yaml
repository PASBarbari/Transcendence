# Default values for login-service-chart.
replicaCount: 1

image:
  repository: bombatomica/login # Changed from nginx to your login service image
  pullPolicy: Always # Changed from IfNotPresent, align with chat service
  tag: latest # Or specify a version

nameOverride: ""
fullnameOverride: ""

namespace:
  name: login
  create: true

service:
  type: ClusterIP # Changed from LoadBalancer (manual manifest) to ClusterIP, common for internal services
  port: 8000 # Port the service will expose
  targetPort: 8000 

serviceAccount:
  dbName: "login-db-service-account"
  create: true
  annotations: {}
  automount: true
  dbAnnotations: {}
  dbAutomount: true

resources:
  limits:
    cpu: 500m
    memory: 512Mi
  requests:
    cpu: 250m
    memory: 256Mi


podAnnotations: {}
podLabels: {}

podSecurityContext: {}
  # fsGroup: 2000

securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000


ingress:
  enabled: true # Assuming you want ingress, similar to chat service
  className: traefik # Your ingress controller class
  annotations: {}
  host: trascendence.42firenze.it # Example host, adjust as needed
  path: /api/login
  pathType: Prefix
  tls:
    enabled: true # Enable TLS, similar to chat service
    secretName: login-tls # Name of the TLS secret, ensure this matches your cert-manager setup
    hosts:
      - trascendence.42firenze.it # Must match ingress.host
  certManager: # Corrected indentation: certManager is a direct child of ingress
    clusterIssuer: selfsigned-issuer

autoscaling:
  enabled: true
  minReplicas: 1
  maxReplicas: 1
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: 80
# Liveness and Readiness Probes
# Adjust paths and ports as per your application's health endpoints
# livenessProbe:
#   httpGet:
#     path: /health # Example, replace with your actual health check endpoint
#     port: http # Refers to the containerPort name 'http'
#   initialDelaySeconds: 30
#   periodSeconds: 20
#   failureThreshold: 3

# readinessProbe:
#   httpGet:
#     path: /health # Example, replace with your actual health check endpoint
#     port: http # Refers to the containerPort name 'http'
#   initialDelaySeconds: 15
#   periodSeconds: 10
#   failureThreshold: 3


# Non-sensitive configurations that will go into a ConfigMap
# These keys will be available as environment variables in your container
configMap:
  data:
    DEBUG: "False"
    DJANGO_SETTINGS_MODULE: "login.settings" # Adjust if your settings module is different
    LOGIN_PORT: "8000" # Port the application inside the container listens on
    LOGIN_HOST: "0.0.0.0" # Host the application binds to
    # Database connection details (host and port)
    # DB_HOST should point to your PostgreSQL service name.
    # Using Release.Name for service names for consistency
    POSTGRES_HOST: "{{ .Release.Name }}-login-db-service" # Use templated service name
    POSTGRES_PORT: "5432" # Default PostgreSQL port
    # URLs for service discovery - using Release.Name for dynamic service names with FQDN
    LOGIN_URL: "http://{{ .Release.Name }}-login-service.login.svc.cluster.local:8000" # Self-referential URL
    CHAT_URL: "http://{{ .Release.Name }}-chat-service.chat.svc.cluster.local:8000"
    USER_URL: "http://{{ .Release.Name }}-user-service.user.svc.cluster.local:8000"
    NOTIFICATIONS_URL: "http://{{ .Release.Name }}-notifications-service.notifications.svc.cluster.local:8000"
    PONG_URL: "http://{{ .Release.Name }}-pong-service.pong.svc.cluster.local:8000"
    # Kubernetes service hosts for ALLOWED_HOSTS (comma-separated)
    K8S_SERVICE_HOSTS: "{{ .Release.Name }}-login-service,{{ .Release.Name }}-login-service.login.svc.cluster.local,{{ .Release.Name }}-chat-service,{{ .Release.Name }}-chat-service.chat.svc.cluster.local,{{ .Release.Name }}-user-service,{{ .Release.Name }}-user-service.user.svc.cluster.local,{{ .Release.Name }}-notifications-service,{{ .Release.Name }}-notifications-service.notifications.svc.cluster.local,{{ .Release.Name }}-pong-service,{{ .Release.Name }}-pong-service.pong.svc.cluster.local"
    ALLOWED_HOSTS: "*" # Be more specific in production

# Sensitive configurations that will go into a Secret
# The keys here (DB_NAME, DB_USER, etc.) are defined in your secret.yaml template
# The actual values will be base64 encoded by the template.
secrets:
  databases:
    login:
      name: "login_db"
      user: "pasquale"
      password: "123456"
  admin:
    username: "pasquale"
    password: "123456"
    email: "pasquale@example.com"
  serviceAuth:
    password: "123"
    secretKey: "bipyIy0zaGN4eThqcTlfdy0qXnlhamwwajcyYXB3cEE1KXM0NTczXjYlazJjZ2IqOT0t"
  oauth:
    google:
      clientId: "PLACEHOLDER_GOOGLE_CLIENT_ID"
      clientSecret: "PLACEHOLDER_GOOGLE_CLIENT_SECRET"
    fortytwo:
      clientId: "u-s4t2ud-2bfa13277753ae18dd3d2a1e2558656b1dddb45e275126ae690788817a769a9a4e"
      clientSecret: "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"

# PostgreSQL subchart configuration (optional, if you want this chart to deploy its own DB)
# If you use an external DB, you can remove or disable this 'db' section
# and ensure DB_HOST, DB_USER, DB_NAME, DB_PASSWORD are correctly set for the external DB.
db:
  enabled: true # Set to true to deploy PostgreSQL along with the login service
  image:
    repository: postgres
    tag: "17" # Specify your desired postgres version
    pullPolicy: IfNotPresent
  service:
    port: 5432
  resources:
    limits:
      cpu: "1"
      memory: "1Gi"
    requests:
      cpu: "250m"
      memory: "256Mi"
  persistence:
    enabled: true
    storageClass: "" # Optional: If blank, uses default SC. Set to "-" to disable SC.
    size: "1Gi"
    annotations: {}
  # PostgreSQL specific environment variables for the subchart
  # These are used to initialize the PostgreSQL instance if db.enabled is true.
  # The login application itself will use the values from .Values.secrets.database.*
  postgresqlUsername: "" # Will default to .Values.secrets.database.user if not set and db.enabled=true
  postgresqlPassword: "" # Will default to .Values.secrets.database.password if not set and db.enabled=true
  postgresqlDatabase: "" # Will default to .Values.secrets.database.name if not set and db.enabled=true
  
  # PostgreSQL Exporter for monitoring
  exporter:
    enabled: true
    image:
      repository: prometheuscommunity/postgres-exporter
      tag: "v0.12.0"
      pullPolicy: IfNotPresent
    resources:
      limits:
        cpu: 100m
        memory: 128Mi
      requests:
        cpu: 50m
        memory: 64Mi

# Additional volumes on the output Deployment definition.
volumes: []
# - name: foo
#   secret:
#     secretName: mysecret
#     optional: false

# Additional volumeMounts on the output Deployment definition.
volumeMounts: []
# - name: foo
#   mountPath: "/etc/foo"
#   readOnly: true

nodeSelector: {}
tolerations: []
affinity: {}