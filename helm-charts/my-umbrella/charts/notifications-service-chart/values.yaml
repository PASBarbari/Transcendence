# Default values for notifications-service-chart.
replicaCount: 1

image:
  repository: bombatomica/notifications # Changed to notifications service image
  pullPolicy: Always
  tag: latest

nameOverride: ""
fullnameOverride: ""

namespace:
  name: notifications
  create: true

service:
  type: ClusterIP
  port: 8000 # Notifications service port exposed to other services
  targetPort: 8000 # Django app listens on 8000 inside container 

serviceAccount:
  dbName: "notifications-db-service-account"
  create: true
  annotations: {}
  automount: true
  dbAnnotations: {}
  dbAutomount: true

resources:
  limits:
    cpu: 500m
    memory: 512Mi
  requests:
    cpu: 250m
    memory: 256Mi


podAnnotations: {}
podLabels: {}

podSecurityContext: {}
  # fsGroup: 2000

securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000


ingress:
  enabled: true
  className: traefik
  annotations: {}
  host: trascendence.42firenze.it
  path: /api/notifications
  pathType: Prefix
  tls:
    enabled: true
    secretName: notifications-tls
    hosts:
      - trascendence.42firenze.it
  certManager:
    clusterIssuer: selfsigned-issuer

autoscaling:
  enabled: true
  minReplicas: 1
  maxReplicas: 1
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: 80
# Liveness and Readiness Probes
# Adjust paths and ports as per your application's health endpoints
# livenessProbe:
#   httpGet:
#     path: /health # Example, replace with your actual health check endpoint
#     port: http # Refers to the containerPort name 'http'
#   initialDelaySeconds: 30
#   periodSeconds: 20
#   failureThreshold: 3

# readinessProbe:
#   httpGet:
#     path: /health # Example, replace with your actual health check endpoint
#     port: http # Refers to the containerPort name 'http'
#   initialDelaySeconds: 15
#   periodSeconds: 10
#   failureThreshold: 3


# Non-sensitive configurations that will go into a ConfigMap
# These keys will be available as environment variables in your container
configMap:
  data:
    DEBUG: "False"
    DJANGO_SETTINGS_MODULE: "Notifications.settings"
    NOTIFICATIONS_PORT: "8000"
    NOTIFICATIONS_HOST: "0.0.0.0"
    POSTGRES_HOST: "{{ .Release.Name }}-notifications-db-service"
    POSTGRES_PORT: "5432"
    LOGIN_URL: "http://{{ .Release.Name }}-login-service.login.svc.cluster.local:8000"
    CHAT_URL: "http://{{ .Release.Name }}-chat-service.chat.svc.cluster.local:8000"
    USER_URL: "http://{{ .Release.Name }}-user-service.user.svc.cluster.local:8000"
    NOTIFICATIONS_URL: "http://{{ .Release.Name }}-notifications-service.notifications.svc.cluster.local:8000"
    PONG_URL: "http://{{ .Release.Name }}-pong-service.pong.svc.cluster.local:8000"
    REDIS_HOST: "{{ .Release.Name }}-redis-chart-service.redis-namespace.svc.cluster.local"
    REDIS_PORT: "6379"
    REDIS_DB: "6" # Redis DB for notifications service
    REDIS_ONLINE_STATUS_DB: "0" # Shared DB for online status
    # Kubernetes service hosts for ALLOWED_HOSTS (comma-separated)
    K8S_SERVICE_HOSTS: "{{ .Release.Name }}-login-service,{{ .Release.Name }}-login-service.login.svc.cluster.local,{{ .Release.Name }}-chat-service,{{ .Release.Name }}-chat-service.chat.svc.cluster.local,{{ .Release.Name }}-user-service,{{ .Release.Name }}-user-service.user.svc.cluster.local,{{ .Release.Name }}-notifications-service,{{ .Release.Name }}-notifications-service.notifications.svc.cluster.local,{{ .Release.Name }}-pong-service,{{ .Release.Name }}-pong-service.pong.svc.cluster.local"
    ALLOWED_HOSTS: "*"

# Sensitive configurations that will go into a Secret
# The keys here (DB_NAME, DB_USER, etc.) are defined in your secret.yaml template
# The actual values will be base64 encoded by the template.
secrets:
  databases:
    notifications:
      name: "notifications_db"
      user: "pasquale"
      password: "123456"
  admin:
    username: "pasquale"
    password: "123456"
    email: "pasquale@example.com"
  serviceAuth:
    password: "123"
    secretKey: "bipyIy0zaGN4eThqcTlfdy0qXnlhamwwajcyYXB3cEE1KXM0NTczXjYlazJjZ2IqOT0t"
  oauth:
    google:
      clientId: "PLACEHOLDER_GOOGLE_CLIENT_ID"
      clientSecret: "PLACEHOLDER_GOOGLE_CLIENT_SECRET"
    fortytwo:
      clientId: "u-s4t2ud-2bfa13277753ae18dd3d2a1e2558656b1dddb45e275126ae690788817a769a9a4e"
      clientSecret: "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"

# PostgreSQL subchart configuration (optional, if you want this chart to deploy its own DB)
# If you use an external DB, you can remove or disable this 'db' section
# and ensure DB_HOST, DB_USER, DB_NAME, DB_PASSWORD are correctly set for the external DB.
db:
  enabled: true # Set to true to deploy PostgreSQL along with the notifications service
  image:
    repository: postgres
    tag: "17" # Specify your desired postgres version
    pullPolicy: IfNotPresent
  service:
    port: 5432
  resources:
    limits:
      cpu: "1"
      memory: "1Gi"
    requests:
      cpu: "250m"
      memory: "256Mi"
  persistence:
    enabled: true
    storageClass: "" # Optional: If blank, uses default SC. Set to "-" to disable SC.
    size: "1Gi"
    annotations: {}
  # PostgreSQL specific environment variables for the subchart
  # These are used to initialize the PostgreSQL instance if db.enabled is true.
  # The notifications application itself will use the values from .Values.secrets.database.*
  postgresqlUsername: "" # Will default to .Values.secrets.database.user if not set and db.enabled=true
  postgresqlPassword: "" # Will default to .Values.secrets.database.password if not set and db.enabled=true
  postgresqlDatabase: "" # Will default to .Values.secrets.database.name if not set and db.enabled=true
  
  # PostgreSQL Exporter for monitoring
  exporter:
    enabled: true
    image:
      repository: prometheuscommunity/postgres-exporter
      tag: "v0.12.0"
      pullPolicy: IfNotPresent
    resources:
      limits:
        cpu: 100m
        memory: 128Mi
      requests:
        cpu: 50m
        memory: 64Mi

# Additional volumes on the output Deployment definition.
volumes: []
# - name: foo
#   secret:
#     secretName: mysecret
#     optional: false

# Additional volumeMounts on the output Deployment definition.
volumeMounts: []
# - name: foo
#   mountPath: "/etc/foo"
#   readOnly: true

nodeSelector: {}
tolerations: []
affinity: {}